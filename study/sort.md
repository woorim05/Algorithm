# 정렬
항목값의 대소 관계에 따라 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업

### 1. 버블 정렬
- 이웃한 두 원소의 대소 관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘(단순 교환 정렬)
- 안정적인 정렬
- 원소를 비교하는 총 횟수 = n(n-1)/2
- 시간 복잡도 O(n<sup>2</sup>)

### 2. 단순 선택 정렬
- 가장 작은 원소부터 선택하여 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 알고리즘
- 안정적이지 않은 정렬(정렬이 필요없는 중복된 값의 위치가 바뀜)
- 원소를 비교하는 총 횟수 = n(n-1)/2
- 시간 복잡도 O(n<sup>2</sup>)

### 3. 단순 삽입 정렬
- 주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘
- 두 번째 원소부터 주목하여 진행, 붙어있는 원소를 비교하며 정렬하므로 안정적인 정렬
- 원소를 비교하는 총 횟수 = n<sup>2</sup>/2
- 시간 복잡도 O(n<sup>2</sup>)

### 4. 쉘 정렬
- 단순 삽입 정렬의 장접은 살리고 단점은 보환하여 더 빠르게 정렬하는 알고리즘
    - 장점: 이미 정렬을 마쳤거나 정렬이 거의 끝나가는 상태에서는 속도가 아주 빠름
    - 단점: 삽입할 위치가 멀리 떨어져 있으면 이동 횟수가 많아짐
- 정렬할 배열의 원소를 그룹으로 나눠 각 그룹별로 졍럴을 수행하여 정렬된 그룹을 합치는 작업을 반복
    - 원소의 이동 횟수를 줄임
- 안정적이지 않은 정렬
- 시간 복잡도 O(n<sup>1.25</sup>)

### 5. 퀵 정렬
- 피벗(그룹을 나누는 기준)을 선택하여 그룹을 나누는 과정을 반복하는 가장 빠른 정렬 알고리즘
- 안정적이지 않은 정렬
- 시간복잡도 O(n long n)
    - 그러나 원소 수가 적은 경우(매번 1개의 원소와 나머지 원소로 나누어지는 경우 등) O(n<sup>2</sup>)이 될 수 있음

### 6. 병합 정렬
- 배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘
- 안정적인 정렬
- 배열 병합의 시간 복잡도는 O(n). 병합 정렬의 단계는 O(n log n)

### 7. 힙 정렬
- 힙의 특성을 이용하여 정렬하는 알고리즘
    - 힙: 부모의 값이 자식의 값보다 항상 크다 라는 조건을 만족하는 완전 이진 트리
- 배열을 힙으로 만들어야 함

### 8. 도수 정렬
- counting sort. 원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘(분포수 세기 정렬)